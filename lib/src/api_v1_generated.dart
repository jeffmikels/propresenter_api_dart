/// AUTOGENERATED ON 2022-04-22 12:14:32.639159

import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';
import 'package:http/http.dart' as http;

class ProApiGeneratedWrapper {
  String host = 'localhost';
  int port = 50001;

  ProApiGeneratedWrapper(this.host, this.port);

  Uri _makeUri(String path, {Map<String, dynamic>? params}) {
    return Uri.http('$host:$port', path, params);
  }

  /// [call] will use the response `content-type` to automatically
  /// determine if the response should be decoded from json or
  /// returned as [Uint8List] directly.
  ///
  /// [path] should be a *relative* path according to the api.
  /// e.g. `/v1/status/updates`
  Future call(String verb, String path, {Map<String, dynamic>? params, Object? data, String? httpAccept}) async {
    httpAccept ??= 'application/json';
    var uri = _makeUri(path, params: params);
    var headers = {'content-type': 'application/json', 'accept': httpAccept};
    late http.Response r;
    switch (verb.toLowerCase()) {
      case 'get':
        r = await http.get(uri, headers: headers);
        break;
      case 'put':
        r = await http.put(uri, headers: headers, body: data);
        break;
      case 'delete':
        r = await http.delete(uri, headers: headers, body: data);
        break;
      case 'post':
        r = await http.post(uri, headers: headers, body: data);
        break;
      case 'patch':
        r = await http.patch(uri, headers: headers, body: data);
        break;
    }
    if (r.statusCode > 199 && r.statusCode < 300) {
      if (r.statusCode == 204) return true;
      if (r.headers['content-type'] == 'application/json') {
        return json.decode(r.body);
      } else {
        return r.bodyBytes;
      }
    } else {
      throw http.ClientException(r.body);
    }
  }

  /// [callStream] acts exactly like [call], but it responds with a stream of Json Objects
  Future<Stream<Map<String, dynamic>>?> callStream(String verb, String path,
      {Map<String, dynamic>? params, Object? data}) async {
    var uri = _makeUri(path, params: params);

    // setup a manual request to manage streaming
    var client = http.Client();
    var verb = data == null ? 'GET' : 'POST';
    var r = http.Request(verb, uri);
    r.headers['content-type'] = 'application/json';
    if (data is String) {
      r.body = data;
    } else {
      r.body = json.encode(data);
    }
    var res = await client.send(r);

    // if successful, create a stream of Json Objects
    if (res.statusCode > 199 && res.statusCode < 300) {
      var sc = StreamController<Map<String, dynamic>>();
      var accum = '';
      var listener = res.stream.listen((e) {
        accum += utf8.decode(e);
        var chunks = accum.split('\r\n\r\n');
        // if the received data ended with \r\n\r\n, the last chunk will be empty
        // if it didn't end with \r\n\r\n, then we want to leave it in the accumulator
        accum = chunks.removeLast();
        for (var chunk in chunks) {
          try {
            var decoded = json.decode(chunk);
            // print(decoded);
            sc.add({...decoded});
          } catch (e) {
            // print('JSON ERROR: $e');
          }
        }
      });

      // cleanup stream
      listener.onDone(() {
        sc.isClosed ? null : sc.close();
      });

      // close http connection when the listener to the stream cancels
      sc.onCancel = () {
        listener.cancel();
        client.close();
      };
      return sc.stream;
    } else {
      // we had an error of some kind, but we used a streaming request
      // so we need to wait until all the response data has arrived
      var err = await _awaitBody(res.stream).timeout(Duration(seconds: 2), onTimeout: () => '"stream timeout"');
      if (err != 'stream timeout' && res.headers['content-type'] == 'application/json') {
        throw http.ClientException(json.decode(err));
      }
      throw http.ClientException(err);
    }
    // return null;
  }

  Future<String> _awaitBody(http.ByteStream s) {
    var accum = <int>[];
    var completer = Completer<String>();
    s.listen((bytes) => accum.addAll(bytes)).onDone(() {
      completer.complete(utf8.decode(accum));
    });
    return completer.future;
  }

  /// `annoucementActiveTimelineOperation` -> `/v1/announcement/active/timeline/{operation}`
  ///
  /// Performs the requested timeline operation for the active announcment presentation.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [operation] : The operation to perform on the timeline
  ///
  /// - Should be one of: `play`, `pause`, `rewind`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> annoucementActiveTimelineOperation(String operation) async {
    String url = '/v1/announcement/active/timeline/$operation';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `announcementActiveTimelineStatus` -> `/v1/announcement/active/timeline`
  ///
  /// Requests the current state of the active announcement timeline.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> announcementActiveTimelineStatus() async {
    String url = '/v1/announcement/active/timeline';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [announcementActiveTimelineStatus]
  Future<Stream<Map<String, dynamic>>?> announcementActiveTimelineStatusStream() async {
    String url = '/v1/announcement/active/timeline';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `audioPlaylistsGet` -> `/v1/audio/playlists`
  ///
  /// Requests a list with all the configured audio playlists.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> audioPlaylistsGet() async {
    String url = '/v1/audio/playlists';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `audioPlaylistGet` -> `/v1/audio/playlist/{playlist_id}`
  ///
  /// Requests a list of all the audio items in the specified audio playlist.
  /// A maximum of 100 items will be returned per call. The `start` query parameter can
  /// be used to retrieve multiple pages of items, by setting it to the index of the first
  /// item to return.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [playlistId] : The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// [start] : The starting index in the list. If the index is out of range, the returned items array will be empty.
  ///
  /// - Example (start): `100`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> audioPlaylistGet(String playlistId, {int? start}) async {
    String url = '/v1/audio/playlist/$playlistId';
    Map<String, dynamic> query = {'start': start.toString()};

    return await call('get', url, params: query, httpAccept: 'application/json');
  }

  /// `audioPlaylistUpdateGet` -> `/v1/audio/playlist/{playlist_id}/updates`
  ///
  /// Requests a chunked data update every time the specified audio playlist changes.
  /// This endpoint can be used to subscribe to changes to a particular playlist.
  /// The response is chunked, where each chunk is a simple string "change".
  /// This string will be sent whenever the audio playlist changes in regards to any of the
  /// data returned by `GET /audio/playlist/{playlist_id}`. The updated playlist data can be
  /// queried by recalling `GET /audio/playlist/{playlist_id}`.
  ///
  /// Note that this endpoint will return nothing unless the `chunked` parameter is set to `true`.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [playlistId] : The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "enum": [
  ///     "change"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> audioPlaylistUpdateGet(String playlistId) async {
    String url = '/v1/audio/playlist/$playlistId/updates';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [audioPlaylistUpdateGet]
  Future<Stream<Map<String, dynamic>>?> audioPlaylistUpdateGetStream(String playlistId) async {
    String url = '/v1/audio/playlist/$playlistId/updates';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `captureStatusGet` -> `/v1/capture/status`
  ///
  /// Requests the current capture status and capture time.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "status",
  ///     "status_description"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> captureStatusGet() async {
    String url = '/v1/capture/status';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [captureStatusGet]
  Future<Stream<Map<String, dynamic>>?> captureStatusGetStream() async {
    String url = '/v1/capture/status';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `captureOperation` -> `/v1/capture/{operation}`
  ///
  /// Performs the requested capture operation (start, stop).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [operation] : The capture operation to perform
  ///
  /// - Should be one of: `start`, `stop`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> captureOperation(String operation) async {
    String url = '/v1/capture/$operation';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `captureSettingsGet` -> `/v1/capture/settings`
  ///
  /// Requests the current capture settings.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "source",
  ///     "audio_routing"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> captureSettingsGet() async {
    String url = '/v1/capture/settings';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `captureModesGet` -> `/v1/capture/encodings/{type}`
  ///
  /// Requests a list of all available capture modes for the capture type (disk, rtmp, resi).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [type] : The required capture type.
  ///
  /// - Should be one of: `disk`, `rtmp`, `resi`
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was completed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> captureModesGet(String type) async {
    String url = '/v1/capture/encodings/$type';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `clearLayer` -> `/v1/clear/layer/{layer}`
  ///
  /// Clears the specified layer (audio, props, messages, announcements, slide, media, video_input).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The name of layer that is to be cleared.
  ///
  /// - Should be one of: `audio`, `props`, `messages`, `announcements`, `slide`, `media`, `video_input`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> clearLayer(String layer) async {
    String url = '/v1/clear/layer/$layer';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `clearGroupGet` -> `/v1/clear/group/{id}`
  ///
  /// Requests the details of the specified clear group.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the required clear group, either name, index or UUID.
  ///
  /// - Example (by_name): `Clear Group`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "layers",
  ///     "icon",
  ///     "tint",
  ///     "stop_timeline_announcements",
  ///     "stop_timeline_presentation",
  ///     "clear_next_presentation"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> clearGroupGet(String id) async {
    String url = '/v1/clear/group/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `clearGroupSet` -> `/v1/clear/group/{id}`
  ///
  /// Sets the details of the specified clear group.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the required clear group, either name, index or UUID.
  ///
  /// - Example (by_name): `Clear Group`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "layers",
  ///     "icon",
  ///     "tint",
  ///     "stop_timeline_announcements",
  ///     "stop_timeline_presentation",
  ///     "clear_next_presentation"
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> clearGroupSet(String id, Map postBody) async {
    String url = '/v1/clear/group/$id';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `clearGroupDelete` -> `/v1/clear/group/{id}`
  ///
  /// Deletes the specified clear group.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the required clear group, either name, index or UUID.
  ///
  /// - Example (by_name): `Clear Group`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> clearGroupDelete(String id) async {
    String url = '/v1/clear/group/$id';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `clearGroupIconGet` -> `/v1/clear/group/{id}/icon`
  ///
  /// Requests the image data for the icon of the specified clear group.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the required clear group, either name, index or UUID.
  ///
  /// - Example (by_name): `Clear Group`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `image/jpeg`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "format": "binary",
  ///   "example": "image data here"
  /// }
  /// ```
  Future<Uint8List> clearGroupIconGet(String id) async {
    String url = '/v1/clear/group/$id/icon';

    return await call('get', url, httpAccept: 'image/jpeg');
  }

  /// `clearGroupIconSet` -> `/v1/clear/group/{id}/icon`
  ///
  /// Sets the custom icon of the specified clear group.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the required clear group, either name, index or UUID.
  ///
  /// - Example (by_name): `Clear Group`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> clearGroupIconSet(String id, String postBody) async {
    String url = '/v1/clear/group/$id/icon';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `clearGroupTrigger` -> `/v1/clear/group/{id}/trigger`
  ///
  /// Triggers the specified clear group.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the required clear group, either name, index or UUID.
  ///
  /// - Example (by_name): `Clear Group`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> clearGroupTrigger(String id) async {
    String url = '/v1/clear/group/$id/trigger';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `clearGroupsGet` -> `/v1/clear/groups`
  ///
  /// Requests a list of all the configured clear groups.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> clearGroupsGet() async {
    String url = '/v1/clear/groups';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `clearGroupCreate` -> `/v1/clear/groups`
  ///
  /// Create a clear group with the details specified.
  /// The UUID and index in the request body are ignored. They will be automatically
  /// assigned and returned in the response body.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "layers",
  ///     "icon",
  ///     "tint",
  ///     "stop_timeline_announcements",
  ///     "stop_timeline_presentation",
  ///     "clear_next_presentation"
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> clearGroupCreate(Map postBody) async {
    String url = '/v1/clear/groups';

    return await call('post', url, httpAccept: 'application/json');
  }

  /// `globalGroupsGet` -> `/v1/groups`
  ///
  /// Requests a list of all the configured global groups.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> globalGroupsGet() async {
    String url = '/v1/groups';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `globalGroupTrigger` -> `/v1/group/{id}`
  ///
  /// Triggers the specified global group.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the required global group, either name, index or UUID.
  ///
  /// - Example (by_name): `Verse 1`
  /// - Example (by_index): `0`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> globalGroupTrigger(String id) async {
    String url = '/v1/group/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `libraryListGet` -> `/v1/libraries`
  ///
  /// Requests a list of all the configured libraries.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> libraryListGet() async {
    String url = '/v1/libraries';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `libraryGet` -> `/v1/library/{library_id}`
  ///
  /// Requests an array of all items in the specified library.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [libraryId] : The ID of the library, either UUID, name, or index, in order of interpretation and search priority.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Library Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "updateType",
  ///     "items"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> libraryGet(String libraryId) async {
    String url = '/v1/library/$libraryId';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [libraryGet]
  Future<Stream<Map<String, dynamic>>?> libraryGetStream(String libraryId) async {
    String url = '/v1/library/$libraryId';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `lookGetAll` -> `/v1/looks`
  ///
  /// Requests a list of all configured audience looks, except the live look.
  /// The current / live look is NOT included. The current look can be retrieved by GET /v1/look/current. While the current look may have the same attributes as one of the looks returned by this endpoint, the current look will have a unique UUID which is not returned by this endpoint.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> lookGetAll() async {
    String url = '/v1/looks';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `lookCreate` -> `/v1/looks`
  ///
  /// Creates a new audience look with the specified details.
  /// The UUID and index are ignored in the request body. They are automatically
  /// assigned and returned as part of the response.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example:
  /// ```json
  /// {
  ///   "id": {
  ///     "uuid": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5C",
  ///     "name": "Look",
  ///     "index": 0
  ///   },
  ///   "screens": [
  ///     {
  ///       "video_input": true,
  ///       "media": true,
  ///       "slide": true,
  ///       "announcements": true,
  ///       "props": true,
  ///       "messages": true,
  ///       "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "mask": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5E"
  ///     },
  ///     {
  ///       "video_input": true,
  ///       "media": true,
  ///       "slide": true,
  ///       "announcements": true,
  ///       "props": true,
  ///       "messages": true,
  ///       "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "mask": null
  ///     },
  ///     {
  ///       "video_input": false,
  ///       "media": false,
  ///       "slide": false,
  ///       "announcements": true,
  ///       "props": false,
  ///       "messages": false,
  ///       "presentation": null,
  ///       "mask": null
  ///     }
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "uuid",
  ///     "index",
  ///     "name",
  ///     "screens"
  ///   ],
  ///   "example": {
  ///     "id": {
  ///       "uuid": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5C",
  ///       "name": "Look",
  ///       "index": 0
  ///     },
  ///     "screens": [
  ///       {
  ///         "video_input": true,
  ///         "media": true,
  ///         "slide": true,
  ///         "announcements": true,
  ///         "props": true,
  ///         "messages": true,
  ///         "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///         "mask": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5E"
  ///       },
  ///       {
  ///         "video_input": true,
  ///         "media": true,
  ///         "slide": true,
  ///         "announcements": true,
  ///         "props": true,
  ///         "messages": true,
  ///         "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///         "mask": null
  ///       },
  ///       {
  ///         "video_input": false,
  ///         "media": false,
  ///         "slide": false,
  ///         "announcements": true,
  ///         "props": false,
  ///         "messages": false,
  ///         "presentation": null,
  ///         "mask": null
  ///       }
  ///     ]
  ///   }
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> lookCreate(Map postBody) async {
    String url = '/v1/looks';

    return await call('post', url, httpAccept: 'application/json');
  }

  /// `lookGetCurrent` -> `/v1/look/current`
  ///
  /// Requests the details of the currently live audience look.
  /// NOTE: The current look is not contained in the looks returned by `GET /v1/looks` as
  /// the current look gets special treatment in ProPresenter and cannot be deleted.
  /// The current look may have the same attributes as one of the other not current saved looks, but it will have a
  /// unique UUID not contained in the response of `GET /v1/looks`. If the current look's attributes match
  /// those of one of the saved looks, the index returned is the index of the matching look in the
  /// array returned by `GET /v1/looks`. If the current look has been modified and its attributes don't
  /// match any of the saved looks, the index returned is the size of the saved looks array.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "uuid",
  ///     "index",
  ///     "name",
  ///     "screens"
  ///   ],
  ///   "example": {
  ///     "id": {
  ///       "uuid": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5C",
  ///       "name": "Look",
  ///       "index": 0
  ///     },
  ///     "screens": [
  ///       {
  ///         "video_input": true,
  ///         "media": true,
  ///         "slide": true,
  ///         "announcements": true,
  ///         "props": true,
  ///         "messages": true,
  ///         "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///         "mask": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5E"
  ///       },
  ///       {
  ///         "video_input": true,
  ///         "media": true,
  ///         "slide": true,
  ///         "announcements": true,
  ///         "props": true,
  ///         "messages": true,
  ///         "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///         "mask": null
  ///       },
  ///       {
  ///         "video_input": false,
  ///         "media": false,
  ///         "slide": false,
  ///         "announcements": true,
  ///         "props": false,
  ///         "messages": false,
  ///         "presentation": null,
  ///         "mask": null
  ///       }
  ///     ]
  ///   }
  /// }
  /// ```
  Future<Map<String, dynamic>> lookGetCurrent() async {
    String url = '/v1/look/current';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [lookGetCurrent]
  Future<Stream<Map<String, dynamic>>?> lookGetCurrentStream() async {
    String url = '/v1/look/current';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `lookSetCurrent` -> `/v1/look/current`
  ///
  /// Sets the details of the currently live audience look.
  /// The UUID and index in the request body are ignored and not applied to the specified look.
  /// For multiple screens, the screens array is applied in order by index to the array of existing screens in the look.
  /// Updates to the screens are done until either the end of the screens update array is reached or the end of the existing screens array is reached.
  /// If the current look is not found in the saved looks (because it is modified but not saved), returns the size of the saved looks array for the index.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (optional) : This is the data that can be sent with this request.
  ///
  /// Example:
  /// ```json
  /// {
  ///   "id": {
  ///     "uuid": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5C",
  ///     "name": "Look",
  ///     "index": 0
  ///   },
  ///   "screens": [
  ///     {
  ///       "video_input": true,
  ///       "media": true,
  ///       "slide": true,
  ///       "announcements": true,
  ///       "props": true,
  ///       "messages": true,
  ///       "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "mask": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5E"
  ///     },
  ///     {
  ///       "video_input": true,
  ///       "media": true,
  ///       "slide": true,
  ///       "announcements": true,
  ///       "props": true,
  ///       "messages": true,
  ///       "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "mask": null
  ///     },
  ///     {
  ///       "video_input": false,
  ///       "media": false,
  ///       "slide": false,
  ///       "announcements": true,
  ///       "props": false,
  ///       "messages": false,
  ///       "presentation": null,
  ///       "mask": null
  ///     }
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> lookSetCurrent(Map postBody) async {
    String url = '/v1/look/current';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `lookGet` -> `/v1/look/{id}`
  ///
  /// Requests the details of the specified audience look.
  /// NOTE: The currently live look is not found by this endpoint. To get the live look use GET /v1/look/current.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the audience look, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Look`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "uuid",
  ///     "index",
  ///     "name",
  ///     "screens"
  ///   ],
  ///   "example": {
  ///     "id": {
  ///       "uuid": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5C",
  ///       "name": "Look",
  ///       "index": 0
  ///     },
  ///     "screens": [
  ///       {
  ///         "video_input": true,
  ///         "media": true,
  ///         "slide": true,
  ///         "announcements": true,
  ///         "props": true,
  ///         "messages": true,
  ///         "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///         "mask": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5E"
  ///       },
  ///       {
  ///         "video_input": true,
  ///         "media": true,
  ///         "slide": true,
  ///         "announcements": true,
  ///         "props": true,
  ///         "messages": true,
  ///         "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///         "mask": null
  ///       },
  ///       {
  ///         "video_input": false,
  ///         "media": false,
  ///         "slide": false,
  ///         "announcements": true,
  ///         "props": false,
  ///         "messages": false,
  ///         "presentation": null,
  ///         "mask": null
  ///       }
  ///     ]
  ///   }
  /// }
  /// ```
  Future<Map<String, dynamic>> lookGet(String id) async {
    String url = '/v1/look/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `lookPut` -> `/v1/look/{id}`
  ///
  /// Sets the details of the specified audience look.
  /// The UUID and index are ignored in the request. They are not modified by this operation.
  /// For multiple screens, the screens array is applied in order by index to the array of existing screens in the look.
  /// Updates to the screens are done until either the end of the screens update array is reached or the end of the existing screens array is reached.
  /// NOTE: The currently live look is not settable by this endpoint. To set the live look use PUT /v1/look/current.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the audience look, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Look`
  /// - Example (by_index): `3`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example:
  /// ```json
  /// {
  ///   "id": {
  ///     "uuid": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5C",
  ///     "name": "Look",
  ///     "index": 0
  ///   },
  ///   "screens": [
  ///     {
  ///       "video_input": true,
  ///       "media": true,
  ///       "slide": true,
  ///       "announcements": true,
  ///       "props": true,
  ///       "messages": true,
  ///       "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "mask": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5E"
  ///     },
  ///     {
  ///       "video_input": true,
  ///       "media": true,
  ///       "slide": true,
  ///       "announcements": true,
  ///       "props": true,
  ///       "messages": true,
  ///       "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "mask": null
  ///     },
  ///     {
  ///       "video_input": false,
  ///       "media": false,
  ///       "slide": false,
  ///       "announcements": true,
  ///       "props": false,
  ///       "messages": false,
  ///       "presentation": null,
  ///       "mask": null
  ///     }
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "uuid",
  ///     "index",
  ///     "name",
  ///     "screens"
  ///   ],
  ///   "example": {
  ///     "id": {
  ///       "uuid": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5C",
  ///       "name": "Look",
  ///       "index": 0
  ///     },
  ///     "screens": [
  ///       {
  ///         "video_input": true,
  ///         "media": true,
  ///         "slide": true,
  ///         "announcements": true,
  ///         "props": true,
  ///         "messages": true,
  ///         "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///         "mask": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5E"
  ///       },
  ///       {
  ///         "video_input": true,
  ///         "media": true,
  ///         "slide": true,
  ///         "announcements": true,
  ///         "props": true,
  ///         "messages": true,
  ///         "presentation": "42C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///         "mask": null
  ///       },
  ///       {
  ///         "video_input": false,
  ///         "media": false,
  ///         "slide": false,
  ///         "announcements": true,
  ///         "props": false,
  ///         "messages": false,
  ///         "presentation": null,
  ///         "mask": null
  ///       }
  ///     ]
  ///   }
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> lookPut(String id, Map postBody) async {
    String url = '/v1/look/$id';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `lookDelete` -> `/v1/look/{id}`
  ///
  /// Deletes the specified audience look from the saved looks.
  /// NOTE: The currently live look may not be deleted.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the audience look, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Look`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> lookDelete(String id) async {
    String url = '/v1/look/$id';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `lookTrigger` -> `/v1/look/{id}/trigger`
  ///
  /// Triggers the specified audience look to make it the live/current look.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the audience look, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Look`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> lookTrigger(String id) async {
    String url = '/v1/look/$id/trigger';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `macroGetAll` -> `/v1/macros`
  ///
  /// Requests a list of all the configured macros.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> macroGetAll() async {
    String url = '/v1/macros';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `macroGet` -> `/v1/macro/{id}`
  ///
  /// Requests the details of the specified macro.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the macro, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Macro`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "color"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> macroGet(String id) async {
    String url = '/v1/macro/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `macroSet` -> `/v1/macro/{id}`
  ///
  /// Sets the details of the specified macro.
  /// The UUID and index in the request body are ignored. They are not updated.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the macro, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Macro`
  /// - Example (by_index): `3`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "color"
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> macroSet(String id, Map postBody) async {
    String url = '/v1/macro/$id';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `macroDelete` -> `/v1/macro/{id}`
  ///
  /// Deletes the specified macro.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the macro, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Macro`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> macroDelete(String id) async {
    String url = '/v1/macro/$id';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `macroTrigger` -> `/v1/macro/{id}/trigger`
  ///
  /// Triggers the specified macro.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the macro, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Macro`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> macroTrigger(String id) async {
    String url = '/v1/macro/$id/trigger';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `maskGetAll` -> `/v1/masks`
  ///
  /// Requests a list of all configured masks.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> maskGetAll() async {
    String url = '/v1/masks';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `maskGet` -> `/v1/mask/{id}`
  ///
  /// Requests the details of the specified mask.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the mask, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Mask`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> maskGet(String id) async {
    String url = '/v1/mask/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `maskThumbnailGet` -> `/v1/mask/{id}/thumbnail`
  ///
  /// Requests a thumbnail image of the specified mask at the given quality value.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the mask, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Mask`
  /// - Example (by_index): `3`
  ///
  /// [quality] : The desired quality of the thumbnail. The value is the number of pixels in the _largest_ dimension of the image,
  /// i.e. if the image is landscape (wider than it is tall), it is the _width_ of the image. If the image is portrait
  /// (taller than it is wide), it is the _height_ of the image.
  ///
  /// Example: `400`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `image/jpeg`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "format": "binary",
  ///   "example": "image data here"
  /// }
  /// ```
  Future<Uint8List> maskThumbnailGet(String id, {int? quality}) async {
    String url = '/v1/mask/$id/thumbnail';
    Map<String, dynamic> query = {'quality': quality.toString()};

    return await call('get', url, params: query, httpAccept: 'image/jpeg');
  }

  /// `mediaPlaylistsGet` -> `/v1/media/playlists`
  ///
  /// Requests a list of all the configured media playlists.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> mediaPlaylistsGet() async {
    String url = '/v1/media/playlists';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `mediaPlaylistGet` -> `/v1/media/playlist/{playlist_id}`
  ///
  /// Requests a list of all the media items in the specified media playlist.
  /// A maximum of 100 items will be returned per call. The `start` query parameter can
  /// be used to retrieve multiple pages of items, by setting it to the index of the first
  /// item to return.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [playlistId] : The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// [start] : The starting index in the list. If the index is out of range, the returned items array will be empty.
  ///
  /// - Example (start): `100`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> mediaPlaylistGet(String playlistId, {int? start}) async {
    String url = '/v1/media/playlist/$playlistId';
    Map<String, dynamic> query = {'start': start.toString()};

    return await call('get', url, params: query, httpAccept: 'application/json');
  }

  /// `mediaPlaylistUpdateGet` -> `/v1/media/playlist/{playlist_id}/updates`
  ///
  /// Requests a chunked data update every time the specified media playlist changes.
  /// This endpoint returns a chunked response, where each chunk is a simple string "change".
  /// This string will be sent whenever the media playlist changes, and the playlist can
  /// be queried using the `/media/playlist/{id}` endpoint.
  ///
  /// Note that this endpoint will return nothing unless the `chunked` parameters is set to `true`
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [playlistId] : The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "enum": [
  ///     "change"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> mediaPlaylistUpdateGet(String playlistId) async {
    String url = '/v1/media/playlist/$playlistId/updates';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [mediaPlaylistUpdateGet]
  Future<Stream<Map<String, dynamic>>?> mediaPlaylistUpdateGetStream(String playlistId) async {
    String url = '/v1/media/playlist/$playlistId/updates';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `mediaThumbnailGet` -> `/v1/media/{uuid}/thumbnail`
  ///
  /// Requests a thumbnail image of the specified media item at the given quality value.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [uuid] : The UUID of the item to look up.
  ///
  /// - Example (uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [quality] : The desired quality of the thumbnail. The value is the number of pixels in the _largest_ dimension of the image,
  /// i.e. if the image is landscape (wider than it is tall), it is the _width_ of the image. If the image is portrait
  /// (taller than it is wide), it is the _height_ of the image.
  ///
  /// Example: `400`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `image/jpeg`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "format": "binary",
  ///   "example": "image data here"
  /// }
  /// ```
  Future<Uint8List> mediaThumbnailGet(String uuid, {int? quality}) async {
    String url = '/v1/media/$uuid/thumbnail';
    Map<String, dynamic> query = {'quality': quality.toString()};

    return await call('get', url, params: query, httpAccept: 'image/jpeg');
  }

  /// `messageGetAll` -> `/v1/messages`
  ///
  /// Requests a list of all configured messages.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> messageGetAll() async {
    String url = '/v1/messages';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [messageGetAll]
  Future<Stream<Map<String, dynamic>>?> messageGetAllStream() async {
    String url = '/v1/messages';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `messageCreate` -> `/v1/messages`
  ///
  /// Creates a new message with specified details.
  /// The UUID and index are ignored in the request body. They are automatically
  /// assigned and returned in the response body.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example:
  /// ```json
  /// {
  ///   "id": {
  ///     "name": "Test Message",
  ///     "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///     "index": 0
  ///   },
  ///   "message": "Text {text}, Clock {System Clock}, Countdown {Timer 1}, Countdown to time {Timer 2}, Elapsed {Timer 3}",
  ///   "tokens": [
  ///     {
  ///       "name": "text",
  ///       "text": {
  ///         "text": "142"
  ///       }
  ///     },
  ///     {
  ///       "name": "System Clock",
  ///       "clock": {
  ///         "format": {
  ///           "date": "short",
  ///           "time": "long",
  ///           "is_24_hours": true
  ///         }
  ///       }
  ///     },
  ///     {
  ///       "name": "Timer 1",
  ///       "timer": {
  ///         "configuration": {
  ///           "id": {
  ///             "name": "Timer 1",
  ///             "uuid": "43b4c5c6-145a-4b19-9968-7b78e6980e82",
  ///             "index": 0
  ///           },
  ///           "allows_overrun": true,
  ///           "countdown": {
  ///             "duration": 300
  ///           }
  ///         },
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         }
  ///       }
  ///     },
  ///     {
  ///       "name": "Timer 2",
  ///       "timer": {
  ///         "configuration": {
  ///           "id": {
  ///             "name": "Timer 2",
  ///             "uuid": "1355b458-5f99-4e6e-8ac7-8522061f6bdb",
  ///             "index": 0
  ///           },
  ///           "allows_overrun": true,
  ///           "count_down_to_time": {
  ///             "time_of_day": "09:30",
  ///             "period": "am"
  ///           }
  ///         },
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         }
  ///       }
  ///     },
  ///     {
  ///       "name": "Timer 3",
  ///       "timer": {
  ///         "configuration": {
  ///           "id": {
  ///             "name": "Timer 3",
  ///             "uuid": "8efe5ec8-daf4-4609-aea2-7c80efa7f6fa",
  ///             "index": 0
  ///           },
  ///           "allows_overrun": true,
  ///           "elapsed": {
  ///             "start_time": 0
  ///           }
  ///         },
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         }
  ///       }
  ///     }
  ///   ],
  ///   "theme": {
  ///     "name": "Default",
  ///     "uuid": "f5468354-01fb-44d8-b7b3-5ede94c6115c",
  ///     "index": 0
  ///   }
  /// }
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "message",
  ///     "theme"
  ///   ],
  ///   "example": {
  ///     "id": {
  ///       "name": "Test Message",
  ///       "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "index": 0
  ///     },
  ///     "message": "Text {text}, Clock {System Clock}, Countdown {Timer 1}, Countdown to time {Timer 2}, Elapsed {Timer 3}",
  ///     "tokens": [
  ///       {
  ///         "name": "text",
  ///         "text": {
  ///           "text": "142"
  ///         }
  ///       },
  ///       {
  ///         "name": "System Clock",
  ///         "clock": {
  ///           "format": {
  ///             "date": "short",
  ///             "time": "long",
  ///             "is_24_hours": true
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 1",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 1",
  ///               "uuid": "43b4c5c6-145a-4b19-9968-7b78e6980e82",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "countdown": {
  ///               "duration": 300
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 2",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 2",
  ///               "uuid": "1355b458-5f99-4e6e-8ac7-8522061f6bdb",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "count_down_to_time": {
  ///               "time_of_day": "09:30",
  ///               "period": "am"
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 3",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 3",
  ///               "uuid": "8efe5ec8-daf4-4609-aea2-7c80efa7f6fa",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "elapsed": {
  ///               "start_time": 0
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       }
  ///     ],
  ///     "theme": {
  ///       "name": "Default",
  ///       "uuid": "f5468354-01fb-44d8-b7b3-5ede94c6115c",
  ///       "index": 0
  ///     }
  ///   }
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> messageCreate(Map postBody) async {
    String url = '/v1/messages';

    return await call('post', url, httpAccept: 'application/json');
  }

  /// `messageGet` -> `/v1/message/{id}`
  ///
  /// Requests the details of the specified message.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the message, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Mask`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "message",
  ///     "theme"
  ///   ],
  ///   "example": {
  ///     "id": {
  ///       "name": "Test Message",
  ///       "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "index": 0
  ///     },
  ///     "message": "Text {text}, Clock {System Clock}, Countdown {Timer 1}, Countdown to time {Timer 2}, Elapsed {Timer 3}",
  ///     "tokens": [
  ///       {
  ///         "name": "text",
  ///         "text": {
  ///           "text": "142"
  ///         }
  ///       },
  ///       {
  ///         "name": "System Clock",
  ///         "clock": {
  ///           "format": {
  ///             "date": "short",
  ///             "time": "long",
  ///             "is_24_hours": true
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 1",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 1",
  ///               "uuid": "43b4c5c6-145a-4b19-9968-7b78e6980e82",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "countdown": {
  ///               "duration": 300
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 2",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 2",
  ///               "uuid": "1355b458-5f99-4e6e-8ac7-8522061f6bdb",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "count_down_to_time": {
  ///               "time_of_day": "09:30",
  ///               "period": "am"
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 3",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 3",
  ///               "uuid": "8efe5ec8-daf4-4609-aea2-7c80efa7f6fa",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "elapsed": {
  ///               "start_time": 0
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       }
  ///     ],
  ///     "theme": {
  ///       "name": "Default",
  ///       "uuid": "f5468354-01fb-44d8-b7b3-5ede94c6115c",
  ///       "index": 0
  ///     }
  ///   }
  /// }
  /// ```
  Future<Map<String, dynamic>> messageGet(String id) async {
    String url = '/v1/message/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `messageSet` -> `/v1/message/{id}`
  ///
  /// Sets the details of the specified message.
  /// The UUID and index in the request body are ignored. They are not updated.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the message, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Mask`
  /// - Example (by_index): `3`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example:
  /// ```json
  /// {
  ///   "id": {
  ///     "name": "Test Message",
  ///     "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///     "index": 0
  ///   },
  ///   "message": "Text {text}, Clock {System Clock}, Countdown {Timer 1}, Countdown to time {Timer 2}, Elapsed {Timer 3}",
  ///   "tokens": [
  ///     {
  ///       "name": "text",
  ///       "text": {
  ///         "text": "142"
  ///       }
  ///     },
  ///     {
  ///       "name": "System Clock",
  ///       "clock": {
  ///         "format": {
  ///           "date": "short",
  ///           "time": "long",
  ///           "is_24_hours": true
  ///         }
  ///       }
  ///     },
  ///     {
  ///       "name": "Timer 1",
  ///       "timer": {
  ///         "configuration": {
  ///           "id": {
  ///             "name": "Timer 1",
  ///             "uuid": "43b4c5c6-145a-4b19-9968-7b78e6980e82",
  ///             "index": 0
  ///           },
  ///           "allows_overrun": true,
  ///           "countdown": {
  ///             "duration": 300
  ///           }
  ///         },
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         }
  ///       }
  ///     },
  ///     {
  ///       "name": "Timer 2",
  ///       "timer": {
  ///         "configuration": {
  ///           "id": {
  ///             "name": "Timer 2",
  ///             "uuid": "1355b458-5f99-4e6e-8ac7-8522061f6bdb",
  ///             "index": 0
  ///           },
  ///           "allows_overrun": true,
  ///           "count_down_to_time": {
  ///             "time_of_day": "09:30",
  ///             "period": "am"
  ///           }
  ///         },
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         }
  ///       }
  ///     },
  ///     {
  ///       "name": "Timer 3",
  ///       "timer": {
  ///         "configuration": {
  ///           "id": {
  ///             "name": "Timer 3",
  ///             "uuid": "8efe5ec8-daf4-4609-aea2-7c80efa7f6fa",
  ///             "index": 0
  ///           },
  ///           "allows_overrun": true,
  ///           "elapsed": {
  ///             "start_time": 0
  ///           }
  ///         },
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         }
  ///       }
  ///     }
  ///   ],
  ///   "theme": {
  ///     "name": "Default",
  ///     "uuid": "f5468354-01fb-44d8-b7b3-5ede94c6115c",
  ///     "index": 0
  ///   }
  /// }
  /// ```
  ///
  /// Example (text_token):
  ///
  /// ```json
  /// {
  ///   "id": {
  ///     "name": "Message with text token",
  ///     "uuid": "",
  ///     "index": 0
  ///   },
  ///   "message": "Please come to room {room}",
  ///   "tokens": [
  ///     {
  ///       "name": "room",
  ///       "text": {
  ///         "text": "142"
  ///       }
  ///     }
  ///   ],
  ///   "theme": {
  ///     "name": "",
  ///     "uuid": "",
  ///     "index": 0
  ///   }
  /// }
  /// ```
  /// Example (clock_token):
  ///
  /// ```json
  /// {
  ///   "id": {
  ///     "name": "Message with clock token",
  ///     "uuid": "",
  ///     "index": 0
  ///   },
  ///   "message": "The current time is {time}",
  ///   "tokens": [
  ///     {
  ///       "name": "time",
  ///       "clock": {
  ///         "format": {
  ///           "date": "short",
  ///           "time": "long",
  ///           "is_24_hours": true
  ///         }
  ///       }
  ///     }
  ///   ],
  ///   "theme": {
  ///     "name": "",
  ///     "uuid": "",
  ///     "index": 0
  ///   }
  /// }
  /// ```
  /// Example (timer_token_countdown):
  ///
  /// ```json
  /// {
  ///   "id": {
  ///     "name": "Message with countdown timer token",
  ///     "uuid": "",
  ///     "index": 0
  ///   },
  ///   "message": "Time until start: {Timer Token}",
  ///   "tokens": [
  ///     {
  ///       "name": "Timer Token",
  ///       "timer": {
  ///         "id": {
  ///           "name": "Countdown Timer",
  ///           "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///           "index": 1
  ///         },
  ///         "allows_overrun": true,
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         },
  ///         "countdown": {
  ///           "duration": 300
  ///         }
  ///       }
  ///     }
  ///   ],
  ///   "theme": {
  ///     "name": "",
  ///     "uuid": "",
  ///     "index": 0
  ///   }
  /// }
  /// ```
  /// Example (timer_token_countdown_to_time):
  ///
  /// ```json
  /// {
  ///   "id": {
  ///     "name": "Message with countdown to time timer token",
  ///     "uuid": "",
  ///     "index": 0
  ///   },
  ///   "message": "Time until start: {Timer Token}",
  ///   "tokens": [
  ///     {
  ///       "name": "Timer Token",
  ///       "timer": {
  ///         "id": {
  ///           "name": "Count Down to Time Timer",
  ///           "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///           "index": 1
  ///         },
  ///         "allows_overrun": true,
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         },
  ///         "count_down_to_time": {
  ///           "time_of_day": 3600,
  ///           "period": "pm"
  ///         }
  ///       }
  ///     }
  ///   ],
  ///   "theme": {
  ///     "name": "",
  ///     "uuid": "",
  ///     "index": 0
  ///   }
  /// }
  /// ```
  /// Example (timer_token_elapsed):
  ///
  /// ```json
  /// {
  ///   "id": {
  ///     "name": "Message with elapsed timer token",
  ///     "uuid": "",
  ///     "index": 0
  ///   },
  ///   "message": "Time since start: {Timer Token}",
  ///   "tokens": [
  ///     {
  ///       "name": "Timer Token",
  ///       "timer": {
  ///         "id": {
  ///           "name": "Elapsed Timer",
  ///           "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///           "index": 1
  ///         },
  ///         "allows_overrun": true,
  ///         "format": {
  ///           "hour": "remove_long",
  ///           "minute": "remove_long",
  ///           "second": "short",
  ///           "millisecond": "none"
  ///         },
  ///         "elapsed": {
  ///           "start_time": 0,
  ///           "end_time": 60
  ///         }
  ///       }
  ///     }
  ///   ],
  ///   "theme": {
  ///     "name": "",
  ///     "uuid": "",
  ///     "index": 0
  ///   }
  /// }
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "message",
  ///     "theme"
  ///   ],
  ///   "example": {
  ///     "id": {
  ///       "name": "Test Message",
  ///       "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "index": 0
  ///     },
  ///     "message": "Text {text}, Clock {System Clock}, Countdown {Timer 1}, Countdown to time {Timer 2}, Elapsed {Timer 3}",
  ///     "tokens": [
  ///       {
  ///         "name": "text",
  ///         "text": {
  ///           "text": "142"
  ///         }
  ///       },
  ///       {
  ///         "name": "System Clock",
  ///         "clock": {
  ///           "format": {
  ///             "date": "short",
  ///             "time": "long",
  ///             "is_24_hours": true
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 1",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 1",
  ///               "uuid": "43b4c5c6-145a-4b19-9968-7b78e6980e82",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "countdown": {
  ///               "duration": 300
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 2",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 2",
  ///               "uuid": "1355b458-5f99-4e6e-8ac7-8522061f6bdb",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "count_down_to_time": {
  ///               "time_of_day": "09:30",
  ///               "period": "am"
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       },
  ///       {
  ///         "name": "Timer 3",
  ///         "timer": {
  ///           "configuration": {
  ///             "id": {
  ///               "name": "Timer 3",
  ///               "uuid": "8efe5ec8-daf4-4609-aea2-7c80efa7f6fa",
  ///               "index": 0
  ///             },
  ///             "allows_overrun": true,
  ///             "elapsed": {
  ///               "start_time": 0
  ///             }
  ///           },
  ///           "format": {
  ///             "hour": "remove_long",
  ///             "minute": "remove_long",
  ///             "second": "short",
  ///             "millisecond": "none"
  ///           }
  ///         }
  ///       }
  ///     ],
  ///     "theme": {
  ///       "name": "Default",
  ///       "uuid": "f5468354-01fb-44d8-b7b3-5ede94c6115c",
  ///       "index": 0
  ///     }
  ///   }
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> messageSet(String id, Map postBody) async {
    String url = '/v1/message/$id';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `messaageDelete` -> `/v1/message/{id}`
  ///
  /// Deletes the specified message.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the message, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Mask`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> messaageDelete(String id) async {
    String url = '/v1/message/$id';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `messageTrigger` -> `/v1/message/{id}/trigger`
  ///
  /// Triggers / Shows the specified message.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the message, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Mask`
  /// - Example (by_index): `3`
  ///
  /// [postBody] (optional) : This is the data that can be sent with this request.
  ///
  /// Example (trigger_message):
  ///
  /// ```json
  /// [
  ///   {
  ///     "name": "My Text Token",
  ///     "text": {
  ///       "text": "Hello, world!"
  ///     }
  ///   },
  ///   {
  ///     "name": "Countdown Timer",
  ///     "timer": {
  ///       "configuration": {
  ///         "allows_overrun": true,
  ///         "countdown": {
  ///           "duration": 3600
  ///         },
  ///         "format": {
  ///           "hour": "none",
  ///           "minute": "short",
  ///           "second": "long",
  ///           "millisecond": "remove_short"
  ///         }
  ///       }
  ///     }
  ///   },
  ///   {
  ///     "name": "Countdown To Time",
  ///     "timer": {
  ///       "configuration": {
  ///         "allows_overrun": true,
  ///         "count_down_to_time": {
  ///           "time_of_day": 1800,
  ///           "period": "pm"
  ///         },
  ///         "format": {
  ///           "hour": "long",
  ///           "minute": "long",
  ///           "second": "none",
  ///           "millisecond": "none"
  ///         }
  ///       }
  ///     }
  ///   },
  ///   {
  ///     "name": "Elapsed Timer",
  ///     "timer": {
  ///       "configuration": {
  ///         "allows_overrun": false,
  ///         "elapsed": {
  ///           "start_time": 0,
  ///           "end_time": 300
  ///         },
  ///         "format": {
  ///           "hour": "none",
  ///           "minute": "short",
  ///           "second": "long",
  ///           "millisecond": "none"
  ///         }
  ///       }
  ///     }
  ///   },
  ///   {
  ///     "name": "My Clock Token",
  ///     "clock": {
  ///       "format": {
  ///         "date": "full",
  ///         "time": "short",
  ///         "is_24_hours": false
  ///       }
  ///     }
  ///   }
  /// ]
  /// ```
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> messageTrigger(String id, List postBody) async {
    String url = '/v1/message/$id/trigger';

    return await call('post', url, httpAccept: 'application/json');
  }

  /// `messageClear` -> `/v1/message/{id}/clear`
  ///
  /// Clears / Hides the specified message.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the message, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Mask`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> messageClear(String id) async {
    String url = '/v1/message/$id/clear';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `findMyMouse` -> `/v1/find_my_mouse`
  ///
  /// Executes the "Find My Mouse" operation.
  ///
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> findMyMouse() async {
    String url = '/v1/findMyMouse';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `playlistGetAll` -> `/v1/playlists`
  ///
  /// Requests a list of all configured playlists.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> playlistGetAll() async {
    String url = '/v1/playlists';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `playlistCreateTopLevel` -> `/v1/playlists`
  ///
  /// Creates a playlist with the specified details.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example (playlist):
  ///
  /// ```json
  /// {
  ///   "name": "Sunday Service",
  ///   "type": "playlist"
  /// }
  /// ```
  /// Example (group):
  ///
  /// ```json
  /// {
  ///   "name": "Evening Services",
  ///   "type": "group"
  /// }
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "oneOf": [
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "type",
  ///         "playlists"
  ///       ]
  ///     },
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "type"
  ///       ]
  ///     }
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> playlistCreateTopLevel(Map postBody) async {
    String url = '/v1/playlists';

    return await call('post', url, httpAccept: 'application/json');
  }

  /// `playlistActiveGet` -> `/v1/playlist/active`
  ///
  /// Requests the details of the active playlist.
  /// The active playlist and playlist item are returned for both the presentation and announcements layers. Active means the most recently triggered presentation or media cue belonging to a library playlist.
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The response was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "presentation",
  ///     "announcements"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> playlistActiveGet() async {
    String url = '/v1/playlist/active';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [playlistActiveGet]
  Future<Stream<Map<String, dynamic>>?> playlistActiveGetStream() async {
    String url = '/v1/playlist/active';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `playlistGet` -> `/v1/playlist/{playlist_id}`
  ///
  /// Requests a list of the items in the specified playlist.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [playlistId] (required) :
  /// The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "items"
  ///   ],
  ///   "example": {
  ///     "id": {
  ///       "index": 0,
  ///       "name": "Sunday Service",
  ///       "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5A"
  ///     },
  ///     "items": [
  ///       {
  ///         "id": {
  ///           "index": 0,
  ///           "name": "Songs",
  ///           "uuid": ""
  ///         },
  ///         "type": "header",
  ///         "is_hidden": true,
  ///         "is_pco": false,
  ///         "header_color": {
  ///           "red": 0,
  ///           "green": 0.54,
  ///           "blue": 0.87,
  ///           "alpha": 1
  ///         }
  ///       },
  ///       {
  ///         "id": {
  ///           "index": 1,
  ///           "name": "Amazing Grace",
  ///           "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5B"
  ///         },
  ///         "type": "presentation",
  ///         "is_hidden": false,
  ///         "is_pco": false
  ///       },
  ///       {
  ///         "id": {
  ///           "index": 2,
  ///           "name": "Graves Into Gardens",
  ///           "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5C"
  ///         },
  ///         "type": "presentation",
  ///         "is_hidden": false,
  ///         "is_pco": false
  ///       },
  ///       {
  ///         "id": {
  ///           "index": 3,
  ///           "name": "Sermon",
  ///           "uuid": ""
  ///         },
  ///         "type": "header",
  ///         "is_hidden": false,
  ///         "is_pco": false,
  ///         "header_color": {
  ///           "red": 0.87,
  ///           "green": 0,
  ///           "blue": 0.54,
  ///           "alpha": 1
  ///         }
  ///       },
  ///       {
  ///         "id": {
  ///           "index": 4,
  ///           "name": "Sermon Notes 2022-01-16",
  ///           "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D"
  ///         },
  ///         "type": "presentation",
  ///         "is_hidden": false,
  ///         "is_pco": false
  ///       }
  ///     ]
  ///   }
  /// }
  /// ```
  Future<Map<String, dynamic>> playlistGet(String playlistId) async {
    String url = '/v1/playlist/$playlistId';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `playlistPut` -> `/v1/playlist/{playlist_id}`
  ///
  /// Sets the contents of the specified playlist.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [playlistId] (required) :
  /// The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example:
  ///
  /// ```json
  /// [
  ///   {
  ///     "id": {
  ///       "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5C",
  ///       "name": "Announcements",
  ///       "index": 0
  ///     },
  ///     "type": "media",
  ///     "is_hidden": true,
  ///     "is_pco": false
  ///   },
  ///   {
  ///     "id": {
  ///       "uuid": null,
  ///       "name": "Songs",
  ///       "index": 1
  ///     },
  ///     "type": "header",
  ///     "header_color": {
  ///       "red": 0,
  ///       "green": 0.54,
  ///       "blue": 0.87,
  ///       "alpha": 1
  ///     },
  ///     "is_hidden": false,
  ///     "is_pco": false
  ///   },
  ///   {
  ///     "id": {
  ///       "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///       "name": "Amazing Grace",
  ///       "index": 2
  ///     },
  ///     "type": "presentation",
  ///     "is_hidden": false,
  ///     "is_pco": false
  ///   }
  /// ]
  /// ```
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> playlistPut(String playlistId, List postBody) async {
    String url = '/v1/playlist/$playlistId';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `playlistCreate` -> `/v1/playlist/{playlist_id}`
  ///
  /// Creates a playlist with the specified details underneath the specified playlist or playlist folder.
  /// An 400 error will be returned if the specified playlist group is not
  /// actually a playlist group (i.e. it is a regular playlist).
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [playlistId] (required) :
  /// The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example (playlist):
  ///
  /// ```json
  /// {
  ///   "name": "Sunday Service",
  ///   "type": "playlist"
  /// }
  /// ```
  /// Example (group):
  ///
  /// ```json
  /// {
  ///   "name": "Evening Services",
  ///   "type": "group"
  /// }
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "oneOf": [
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "type",
  ///         "playlists"
  ///       ]
  ///     },
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "type"
  ///       ]
  ///     }
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> playlistCreate(String playlistId, Map postBody) async {
    String url = '/v1/playlist/$playlistId';

    return await call('post', url, httpAccept: 'application/json');
  }

  /// `presentationGetActive` -> `/v1/presentation/current`
  ///
  /// Requests the details of the currently active presentation.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> presentationGetActive() async {
    String url = '/v1/presentation/current';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [presentationGetActive]
  Future<Stream<Map<String, dynamic>>?> presentationGetActiveStream() async {
    String url = '/v1/presentation/current';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `presentationGetSlideIndex` -> `/v1/presentation/slide_index`
  ///
  /// Requests the index of the current slide/cue within the currently active presentation.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> presentationGetSlideIndex() async {
    String url = '/v1/presentation/slideIndex';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [presentationGetSlideIndex]
  Future<Stream<Map<String, dynamic>>?> presentationGetSlideIndexStream() async {
    String url = '/v1/presentation/slideIndex';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `presentationGetChordChart` -> `/v1/presentation/chord_chart`
  ///
  /// Requests the current chord chart image (if available) at the given quality value.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [quality] : The desired quality of the thumbnail. The value is the number of pixels in the _largest_ dimension of the image,
  /// i.e. if the image is landscape (wider than it is tall), it is the _width_ of the image. If the image is portrait
  /// (taller than it is wide), it is the _height_ of the image.
  ///
  /// Example: `400`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `image/jpeg`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "format": "binary",
  ///   "example": "image data here"
  /// }
  /// ```
  Future<Uint8List> presentationGetChordChart({int? quality}) async {
    String url = '/v1/presentation/chordChart';
    Map<String, dynamic> query = {'quality': quality.toString()};

    return await call('get', url, params: query, httpAccept: 'image/jpeg');
  }

  /// `presentationGetChordChartUpdates` -> `/v1/presentation/chord_chart/updates`
  ///
  /// Requests a chunked data update every time the chord chart changes.
  /// This endpoint can be used to subscribe to changes to the chord chart.
  /// The response is chunked, where each chunk is a simple string "change".
  /// This string will be sent whenever the chord chart changes.
  /// The updated chord chart can be queried by recalling `GET /presentation/chord_chart`.
  ///
  /// Note that this endpoint will return nothing unless the `chunked` parameter is set to `true`.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "enum": [
  ///     "change"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> presentationGetChordChartUpdates() async {
    String url = '/v1/presentation/chordChart/updates';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [presentationGetChordChartUpdates]
  Future<Stream<Map<String, dynamic>>?> presentationGetChordChartUpdatesStream() async {
    String url = '/v1/presentation/chordChart/updates';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `presentationGet` -> `/v1/presentation/{uuid}`
  ///
  /// Requests the details of the specified presentation.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [uuid] : The UUID of the presentation to look up.
  ///
  /// - Example (uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "groups",
  ///     "name",
  ///     "has_timeline",
  ///     "current_location",
  ///     "destination"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> presentationGet(String uuid) async {
    String url = '/v1/presentation/$uuid';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `presentationTrigger` -> `/v1/presentation/{uuid}/trigger`
  ///
  /// Triggers the specified presentation.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [uuid] : The UUID of the presentation to look up.
  ///
  /// - Example (uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> presentationTrigger(String uuid) async {
    String url = '/v1/presentation/$uuid/trigger';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `presentationTriggerCue` -> `/v1/presentation/{uuid}/trigger/{index}`
  ///
  /// Triggers the specified cue inside the specified presentation.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [uuid] : The UUID of the presentation to look up.
  ///
  /// - Example (uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [index] : The index of the cue to use. Respects the selected arrangement of cues.
  ///
  /// - Example (index): `0`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> presentationTriggerCue(String uuid, int index) async {
    String url = '/v1/presentation/$uuid/trigger/$index';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `presentationActiveTimelineStatus` -> `/v1/presentation/active/timeline`
  ///
  /// Requests the current state of the active presentation timeline.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> presentationActiveTimelineStatus() async {
    String url = '/v1/presentation/active/timeline';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [presentationActiveTimelineStatus]
  Future<Stream<Map<String, dynamic>>?> presentationActiveTimelineStatusStream() async {
    String url = '/v1/presentation/active/timeline';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `presentationFocusedTimelineStatus` -> `/v1/presentation/focused/timeline`
  ///
  /// Requests the current state of the focused presentation timeline.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> presentationFocusedTimelineStatus() async {
    String url = '/v1/presentation/focused/timeline';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [presentationFocusedTimelineStatus]
  Future<Stream<Map<String, dynamic>>?> presentationFocusedTimelineStatusStream() async {
    String url = '/v1/presentation/focused/timeline';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `presentationActiveTimelineOperation` -> `/v1/presentation/active/timeline/{operation}`
  ///
  /// Performs the requested timeline operation for the active presentation.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [operation] : The operation to perform on the timeline
  ///
  /// - Should be one of: `play`, `pause`, `rewind`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> presentationActiveTimelineOperation(String operation) async {
    String url = '/v1/presentation/active/timeline/$operation';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `presentationFocusedTimelineOperation` -> `/v1/presentation/focused/timeline/{operation}`
  ///
  /// Performs the requested timeline operation for the currently active presentation (play, pause, rewind).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [operation] : The operation to perform on the timeline
  ///
  /// - Should be one of: `play`, `pause`, `rewind`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> presentationFocusedTimelineOperation(String operation) async {
    String url = '/v1/presentation/focused/timeline/$operation';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `presentationTimelineOperation` -> `/v1/presentation/{uuid}/timeline/{operation}`
  ///
  /// Performs the requested timeline operation for the specified presentation (play, pause, rewind).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [uuid] : The UUID of the presentation to look up.
  ///
  /// - Example (uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [operation] : The operation to perform on the timeline
  ///
  /// - Should be one of: `play`, `pause`, `rewind`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> presentationTimelineOperation(String uuid, String operation) async {
    String url = '/v1/presentation/$uuid/timeline/$operation';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `presentationThumbnailGet` -> `/v1/presentation/{uuid}/thumbnail/{index}`
  ///
  /// Requests a thumbnail image of the specified cue inside the specified presentation at the given quality value.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [uuid] : The UUID of the presentation to look up.
  ///
  /// - Example (uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [index] : The index of the cue to use. Respects the selected arrangement of cues.
  ///
  /// - Example (index): `0`
  ///
  /// [quality] : The desired quality of the thumbnail. The value is the number of pixels in the _largest_ dimension of the image,
  /// i.e. if the image is landscape (wider than it is tall), it is the _width_ of the image. If the image is portrait
  /// (taller than it is wide), it is the _height_ of the image.
  ///
  /// Example: `400`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `image/jpeg`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "format": "binary",
  ///   "example": "image data here"
  /// }
  /// ```
  ///
  /// ## RESPONSE 403:
  ///
  /// The request was not authorized.
  ///
  /// content-type: ``
  ///
  Future<Uint8List> presentationThumbnailGet(String uuid, int index, {int? quality}) async {
    String url = '/v1/presentation/$uuid/thumbnail/$index';
    Map<String, dynamic> query = {'quality': quality.toString()};

    return await call('get', url, params: query, httpAccept: 'image/jpeg');
  }

  /// `propGetAll` -> `/v1/props`
  ///
  /// Gets a list of all the props.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was completed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> propGetAll() async {
    String url = '/v1/props';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [propGetAll]
  Future<Stream<Map<String, dynamic>>?> propGetAllStream() async {
    String url = '/v1/props';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `propGet` -> `/v1/prop/{id}`
  ///
  /// Requests the details of the specified prop.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the prop, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Prop Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> propGet(String id) async {
    String url = '/v1/prop/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `propDelete` -> `/v1/prop/{id}`
  ///
  /// Deletes the specified prop.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the prop, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Prop Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> propDelete(String id) async {
    String url = '/v1/prop/$id';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `propTrigger` -> `/v1/prop/{id}/trigger`
  ///
  /// Triggers the specified prop.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the prop, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Prop Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> propTrigger(String id) async {
    String url = '/v1/prop/$id/trigger';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `propClear` -> `/v1/prop/{id}/clear`
  ///
  /// Clears the specified prop.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the prop, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Prop Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> propClear(String id) async {
    String url = '/v1/prop/$id/clear';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `propThumbnailGet` -> `/v1/prop/{id}/thumbnail`
  ///
  /// Requests a thumbnail image of the specified prop at the given quality value.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the prop, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Prop Name`
  /// - Example (by_index): `3`
  ///
  /// [quality] : The desired quality of the thumbnail. The value is the number of pixels in the _largest_ dimension of the image,
  /// i.e. if the image is landscape (wider than it is tall), it is the _width_ of the image. If the image is portrait
  /// (taller than it is wide), it is the _height_ of the image.
  ///
  /// Example: `400`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `image/jpeg`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "format": "binary",
  ///   "example": "image data here"
  /// }
  /// ```
  Future<Uint8List> propThumbnailGet(String id, {int? quality}) async {
    String url = '/v1/prop/$id/thumbnail';
    Map<String, dynamic> query = {'quality': quality.toString()};

    return await call('get', url, params: query, httpAccept: 'image/jpeg');
  }

  /// `stageMessageGet` -> `/v1/stage/message`
  ///
  /// Requests the currently active stage message.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The response was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> stageMessageGet() async {
    String url = '/v1/stage/message';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [stageMessageGet]
  Future<Stream<Map<String, dynamic>>?> stageMessageGetStream() async {
    String url = '/v1/stage/message';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `stageMessageShow` -> `/v1/stage/message`
  ///
  /// Shows the specified stage message on the configured stage screen.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example:
  /// ```json
  /// "Your message here"
  /// ```
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> stageMessageShow(String postBody) async {
    String url = '/v1/stage/message';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `stageMessageHide` -> `/v1/stage/message`
  ///
  /// Hides the currently displayed stage message from the configured stage screen.
  ///
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> stageMessageHide() async {
    String url = '/v1/stage/message';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `stageLayoutMapGet` -> `/v1/stage/layout_map`
  ///
  /// Requests the currently selected stage layout for each configured stage screen.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> stageLayoutMapGet() async {
    String url = '/v1/stage/layoutMap';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `stageLayoutMapSet` -> `/v1/stage/layout_map`
  ///
  /// Sets the specified stage message to the corresponding stage screens.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example (set_layouts_by_name):
  ///
  /// ```json
  /// [
  ///   {
  ///     "screen": {
  ///       "name": "Side Screen"
  ///     },
  ///     "layout": {
  ///       "name": "Sermon Notes"
  ///     }
  ///   }
  /// ]
  /// ```
  /// Example (set_layouts_by_index):
  ///
  /// ```json
  /// [
  ///   {
  ///     "screen": {
  ///       "index": 3
  ///     },
  ///     "layout": {
  ///       "index": 7
  ///     }
  ///   }
  /// ]
  /// ```
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> stageLayoutMapSet(List postBody) async {
    String url = '/v1/stage/layoutMap';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `stageScreensGet` -> `/v1/stage/screens`
  ///
  /// Requests a list of the configured stage screens.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": [],
  ///   "example": [
  ///     {
  ///       "id": {
  ///         "name": "Stage Left",
  ///         "index": 0,
  ///         "uuid": "BB6E8C3A-8182-4818-8D57-38B1D85333A9"
  ///       }
  ///     },
  ///     {
  ///       "id": {
  ///         "name": "Stage Right",
  ///         "index": 1,
  ///         "uuid": "D2BAE32A-CDE2-4166-BA5C-2276D51EEFB8"
  ///       }
  ///     }
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> stageScreensGet() async {
    String url = '/v1/stage/screens';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `stageScreenLayoutGet` -> `/v1/stage/screen/{id}/layout`
  ///
  /// Requests the current stage layout for the specified stage screen.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the screen, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Screen Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "uuid",
  ///     "name",
  ///     "index"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> stageScreenLayoutGet(String id) async {
    String url = '/v1/stage/screen/$id/layout';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `stageScreenLayoutSet` -> `/v1/stage/screen/{id}/layout/{layout_id}`
  ///
  /// Sets the specified stage layout for the specified stage screen.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the screen, either UUID, name, or index.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Screen Name`
  /// - Example (by_index): `3`
  ///
  /// [layoutId] : The ID of the stage layout, either name, index or UUID.
  ///
  /// - Example (by_name): `Layout Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> stageScreenLayoutSet(String id, String layoutId) async {
    String url = '/v1/stage/screen/$id/layout/$layoutId';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `stageLayoutsGet` -> `/v1/stage/layouts`
  ///
  /// Requests a list of the configured stage layouts.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": [],
  ///   "example": [
  ///     {
  ///       "id": {
  ///         "name": "Current/Next Stacked - Music",
  ///         "index": 0,
  ///         "uuid": "4D542943-6CF2-4BEE-A625-7C37B79D8EEF"
  ///       }
  ///     },
  ///     {
  ///       "id": {
  ///         "name": "Main Screen Preview",
  ///         "index": 1,
  ///         "uiuid": "D2BAE32A-CDE2-4166-BA5C-2276D51EEFB8"
  ///       }
  ///     }
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> stageLayoutsGet() async {
    String url = '/v1/stage/layouts';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `stageLayoutDelete` -> `/v1/stage/layout/{layout_id}`
  ///
  /// Deletes the specified stage layout.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layoutId] : The ID of the stage layout, either name, index or UUID.
  ///
  /// - Example (by_name): `Layout Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> stageLayoutDelete(String layoutId) async {
    String url = '/v1/stage/layout/$layoutId';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `stageLayoutThumbnailGet` -> `/v1/stage/layout/{layout_id}/thumbnail`
  ///
  /// Requests a thumbnail image of the specified stage layout at the given quality value.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layoutId] : The ID of the stage layout, either name, index or UUID.
  ///
  /// - Example (by_name): `Layout Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [quality] : The desired quality of the thumbnail. The value is the number of pixels in the _largest_ dimension of the image,
  /// i.e. if the image is landscape (wider than it is tall), it is the _width_ of the image. If the image is portrait
  /// (taller than it is wide), it is the _height_ of the image.
  ///
  /// Example: `400`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `image/jpeg`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "format": "binary",
  ///   "example": "image data here"
  /// }
  /// ```
  Future<Uint8List> stageLayoutThumbnailGet(String layoutId, {int? quality}) async {
    String url = '/v1/stage/layout/$layoutId/thumbnail';
    Map<String, dynamic> query = {'quality': quality.toString()};

    return await call('get', url, params: query, httpAccept: 'image/jpeg');
  }

  /// `versionGet` -> `/version`
  ///
  /// Requests the general information about the currently active ProPresenter instance.
  /// Note that this endpoint is not versioned, and will always reside at `/version` regardless of the current
  /// API version. The structure of this response may change, but the fields described below will always exist in
  /// their current form, maintaining backward compatibility.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The response was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "name",
  ///     "platform",
  ///     "os_version",
  ///     "host_description",
  ///     "api_version"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> versionGet() async {
    String url = '/version';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `layerStatusGet` -> `/v1/status/layers`
  ///
  /// Requests the status of all available layers.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The response was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "video_input",
  ///     "media",
  ///     "slide",
  ///     "announcements",
  ///     "props",
  ///     "messaages",
  ///     "audio"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> layerStatusGet() async {
    String url = '/v1/status/layers';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [layerStatusGet]
  Future<Stream<Map<String, dynamic>>?> layerStatusGetStream() async {
    String url = '/v1/status/layers';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `stageScreensStatusGet` -> `/v1/status/stage_screens`
  ///
  /// Requests the status of the stage screens.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The response was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "boolean",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> stageScreensStatusGet() async {
    String url = '/v1/status/stageScreens';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [stageScreensStatusGet]
  Future<Stream<Map<String, dynamic>>?> stageScreensStatusGetStream() async {
    String url = '/v1/status/stageScreens';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `stageScreensStatusSet` -> `/v1/status/stage_screens`
  ///
  /// Sets the status of the stage screens.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> stageScreensStatusSet(bool postBody) async {
    String url = '/v1/status/stageScreens';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `audienceScreensStatusGet` -> `/v1/status/audience_screens`
  ///
  /// Requests the status of the audience screens.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The response was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "boolean",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> audienceScreensStatusGet() async {
    String url = '/v1/status/audienceScreens';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [audienceScreensStatusGet]
  Future<Stream<Map<String, dynamic>>?> audienceScreensStatusGetStream() async {
    String url = '/v1/status/audienceScreens';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `audienceScreensStatusSet` -> `/v1/status/audience_screens`
  ///
  /// Sets the status of the audience screens.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> audienceScreensStatusSet(bool postBody) async {
    String url = '/v1/status/audienceScreens';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `statusScreensGet` -> `/v1/status/screens`
  ///
  /// Requests the details of all configured screens.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> statusScreensGet() async {
    String url = '/v1/status/screens';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [statusScreensGet]
  Future<Stream<Map<String, dynamic>>?> statusScreensGetStream() async {
    String url = '/v1/status/screens';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `slideStatusGet` -> `/v1/status/slide`
  ///
  /// Requests the current/next slide text and image UUIDs.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The response was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> slideStatusGet() async {
    String url = '/v1/status/slide';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [slideStatusGet]
  Future<Stream<Map<String, dynamic>>?> slideStatusGetStream() async {
    String url = '/v1/status/slide';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `statusUpdatesGet` -> `/v1/status/updates`
  ///
  /// Aggregates the data from one or more streaming endpoints into a single streaming endpoint.
  /// This endpoint is used to overcome a browser limit on the number of concurrent connections allowed. The following
  /// endpoints are permitted here:
  ///   * [announcement/active/timeline](#/Announcement/announcementActiveTimelineStatus)
  ///   * [audio/playlist/{id}/updates](#/Audio/audioPlaylistUpdateGet)
  ///   * [capture/status](#/Capture/captureStatusGet)
  ///   * [library/{id}](#/Library/libraryGet)
  ///   * [look/current](#/Looks/lookGetCurrent)
  ///   * [media/playlist/{id}/updates](#/Media/mediaPlaylistUpdateGet)
  ///   * [messages](#/Message/messageGetAll)
  ///   * [playlist/current](#/Playlist/playlistCurrentGet)
  ///   * [presentation/current](#/Presentation/presentationGetCurrent)
  ///   * [presentation/slide_index](#/Presentation/presentationGetSlideIndex)
  ///   * [presentation/active/timeline](#/Presentation/presentationActiveTimelineStatus)
  ///   * [presentation/focused/timeline](#/Presentation/presentationFocusedTimelineStatus)
  ///   * [stage/message](#/Stage/stageMessageGet)
  ///   * [status/layers](#/Status/layerStatusGet)
  ///   * [status/stage_screens](#/Status/stageScreensStatusGet)
  ///   * [status/audience_screens](#/Status/audienceScreensStatusGet)
  ///   * [status/screens](#/Status/statusScreensGet)
  ///   * [status/slide](#/Status/slideStatusGet)
  ///   * [timers](#/Timer/timerGetAll)
  ///   * [timers/current](#/Timer/timerGetCurrentTimes)
  ///   * [timer/system_time](#/Timer/timerGetSystemTime)
  ///   * [timer/video_countdown](#/Timer/timerGetVideoCountdown)
  ///   * [transport/{layer}/time](#/Transport/transportTimeGet)
  ///   * [transport/{layer}/current](#/Transport/transportCurrentMediaGet)
  ///
  /// In particular, all (and only) GET requests that return a chunked JSON response are legal URLs.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example (one_url):
  ///
  /// ```json
  /// [
  ///   "status/slide"
  /// ]
  /// ```
  /// Example (multi_urls):
  ///
  /// ```json
  /// [
  ///   "status/slide",
  ///   "timer/video_countdown",
  ///   "presentation/current"
  /// ]
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully. A stream of updates will be returned to the client as they
  /// become available. Each update is separated by a CRLF pair, so a section of data followed by a
  /// CR-LF-CR-LF sequence is one update. Each update is a JSON object, as below.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": []
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The given request was invalid. This can be caused by a number of things:
  ///   * The given URL was not found.
  ///   * The given URL is not a streaming URL (i.e. it does not return a chunked response).
  ///   * The given URL does not return a JSON data type.
  ///
  /// The response body contains a list of URLs that were not valid.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Stream<Map<String, dynamic>>?> statusUpdatesGet(List postBody) async {
    String url = '/v1/status/updates';
    return callStream('get', url, data: postBody);
  }

  /// `themeGetAll` -> `/v1/themes`
  ///
  /// Requests a list of all configured themes and theme slides.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> themeGetAll() async {
    String url = '/v1/themes';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `themeGet` -> `/v1/theme/{id}`
  ///
  /// Requests the details of the theme and theme slides.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the theme, either name or index.
  ///
  /// - Example (by_name): `Theme Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id",
  ///     "slides"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> themeGet(String id) async {
    String url = '/v1/theme/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `themeSlideGet` -> `/v1/theme/{id}/slides/{theme_slide}`
  ///
  /// Requests the details of the specified theme slide within the specified theme.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the theme, either name or index.
  ///
  /// - Example (by_name): `Theme Name`
  /// - Example (by_index): `3`
  /// [themeSlide] (optional) :
  /// The ID of the theme slide, either name, index or UUID.
  ///
  /// - Example (by_name): `Theme Slide Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "id"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> themeSlideGet(String id, {String? themeSlide}) async {
    String url = '/v1/theme/$id/slides/$themeSlide';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `themeSlideSet` -> `/v1/theme/{id}/slides/{theme_slide}`
  ///
  /// Sets the details of the specified theme slide within the specified theme.
  /// The UUID and index in the request body are ignored, and are not changed by this request.
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the theme, either name or index.
  ///
  /// - Example (by_name): `Theme Name`
  /// - Example (by_index): `3`
  /// [themeSlide] (optional) :
  /// The ID of the theme slide, either name, index or UUID.
  ///
  /// - Example (by_name): `Theme Slide Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [postBody] (optional) : This is the data that can be sent with this request.
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> themeSlideSet(String id, Map postBody, {String? themeSlide}) async {
    String url = '/v1/theme/$id/slides/$themeSlide';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `themeSlideThumbnailGet` -> `/v1/theme/{id}/slides/{theme_slide}/thumbnail`
  ///
  /// Requests a thumbnail image of the specified theme slide at the given quality value.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the theme, either name or index.
  ///
  /// - Example (by_name): `Theme Name`
  /// - Example (by_index): `3`
  ///
  /// [themeSlide] : The ID of the theme slide, either name, index or UUID.
  ///
  /// - Example (by_name): `Theme Slide Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [quality] : The desired quality of the thumbnail. The value is the number of pixels in the _largest_ dimension of the image,
  /// i.e. if the image is landscape (wider than it is tall), it is the _width_ of the image. If the image is portrait
  /// (taller than it is wide), it is the _height_ of the image.
  ///
  /// Example: `400`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `image/jpeg`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "format": "binary",
  ///   "example": "image data here"
  /// }
  /// ```
  Future<Uint8List> themeSlideThumbnailGet(String id, {String? themeSlide, int? quality}) async {
    String url = '/v1/theme/$id/slides/$themeSlide/thumbnail';
    Map<String, dynamic> query = {'quality': quality.toString()};

    return await call('get', url, params: query, httpAccept: 'image/jpeg');
  }

  /// `timerGetAll` -> `/v1/timers`
  ///
  /// Requests the details for all configured timers.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> timerGetAll() async {
    String url = '/v1/timers';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [timerGetAll]
  Future<Stream<Map<String, dynamic>>?> timerGetAllStream() async {
    String url = '/v1/timers';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `timerCreate` -> `/v1/timers`
  ///
  /// Creates a new timer with the specified details.
  /// The newly created timer's UUID and index are returned in the response body.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [postBody] (optional) : This is the data that can be sent with this request.
  ///
  /// Example (set_configuration_countdown):
  ///
  /// ```json
  /// {
  ///   "name": "Timer 1",
  ///   "allows_overrun": true,
  ///   "countdown": {
  ///     "duration": 300
  ///   }
  /// }
  /// ```
  /// Example (set_configuration_countdown_to_time):
  ///
  /// ```json
  /// {
  ///   "name": "Timer 1",
  ///   "allows_overrun": true,
  ///   "count_down_to_time": {
  ///     "time_of_day": 3600,
  ///     "period": "pm"
  ///   }
  /// }
  /// ```
  /// Example (set_configuration_elapsed):
  ///
  /// ```json
  /// {
  ///   "name": "Timer 1",
  ///   "allows_overrun": true,
  ///   "elapsed": {
  ///     "start_time": 0,
  ///     "end_time": 120
  ///   }
  /// }
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "oneOf": [
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     },
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     },
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     }
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> timerCreate(String postBody) async {
    String url = '/v1/timers';

    return await call('post', url, httpAccept: 'application/json');
  }

  /// `timerGetCurrentTimes` -> `/v1/timers/current`
  ///
  /// Requests the current time for all configured timers.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> timerGetCurrentTimes() async {
    String url = '/v1/timers/current';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [timerGetCurrentTimes]
  Future<Stream<Map<String, dynamic>>?> timerGetCurrentTimesStream() async {
    String url = '/v1/timers/current';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `timerOperationAll` -> `/v1/timers/{operation}`
  ///
  /// Performs the requested operation for all configured timers (start, stop, reset).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [operation] : The operation to perform on the timer
  ///
  /// - Should be one of: `start`, `stop`, `reset`
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: ``
  ///
  Future<Uint8List> timerOperationAll(String operation) async {
    String url = '/v1/timers/$operation';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `timerGet` -> `/v1/timer/{id}`
  ///
  /// Requests the details of the specified timer.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the timer, either name, index or UUID.
  ///
  /// - Example (by_name): `Timer Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "oneOf": [
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     },
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     },
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     }
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> timerGet(String id) async {
    String url = '/v1/timer/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `timerSet` -> `/v1/timer/{id}`
  ///
  /// Sets the details of the specified timer.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the timer, either name, index or UUID.
  ///
  /// - Example (by_name): `Timer Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example (set_configuration_countdown):
  ///
  /// ```json
  /// {
  ///   "id": {
  ///     "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///     "name": "Timer 1",
  ///     "index": 0
  ///   },
  ///   "allows_overrun": true,
  ///   "countdown": {
  ///     "duration": 300
  ///   }
  /// }
  /// ```
  /// Example (set_configuration_countdown_to_time):
  ///
  /// ```json
  /// {
  ///   "id": {
  ///     "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///     "name": "Timer 1",
  ///     "index": 0
  ///   },
  ///   "allows_overrun": true,
  ///   "count_down_to_time": {
  ///     "time_of_day": 3600,
  ///     "period": "pm"
  ///   }
  /// }
  /// ```
  /// Example (set_configuration_elapsed):
  ///
  /// ```json
  /// {
  ///   "id": {
  ///     "uuid": "942C3FC3-C4B2-44F7-A55D-4CC913BB8A5D",
  ///     "name": "Timer 1",
  ///     "index": 0
  ///   },
  ///   "allows_overrun": true,
  ///   "elapsed": {
  ///     "start_time": 0,
  ///     "end_time": 120
  ///   }
  /// }
  /// ```
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "oneOf": [
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     },
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     },
  ///     {
  ///       "type": "object",
  ///       "required": [
  ///         "id",
  ///         "allows_overrun"
  ///       ]
  ///     }
  ///   ]
  /// }
  /// ```
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<Map<String, dynamic>> timerSet(String id, String postBody) async {
    String url = '/v1/timer/$id';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `timerDelete` -> `/v1/timer/{id}`
  ///
  /// Deletes the specified timer.
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [id] (required) :
  /// The ID of the timer, either name, index or UUID.
  ///
  /// - Example (by_name): `Timer Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> timerDelete(String id) async {
    String url = '/v1/timer/$id';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `timerOperation` -> `/v1/timer/{id}/{operation}`
  ///
  /// Performs the requested operation on the specified timer (start, stop, reset).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the timer, either name, index or UUID.
  ///
  /// - Example (by_name): `Timer Name`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// [operation] : The operation to perform on the timer
  ///
  /// - Should be one of: `start`, `stop`, `reset`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> timerOperation(String id, String operation) async {
    String url = '/v1/timer/$id/$operation';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `timerGetSystemTime` -> `/v1/timer/system_time`
  ///
  /// Requests the current system time.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "integer",
  ///   "required": [],
  ///   "example": 1628029541
  /// }
  /// ```
  Future<Map<String, dynamic>> timerGetSystemTime() async {
    String url = '/v1/timer/systemTime';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [timerGetSystemTime]
  Future<Stream<Map<String, dynamic>>?> timerGetSystemTimeStream() async {
    String url = '/v1/timer/systemTime';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `timerGetVideoCountdown` -> `/v1/timer/video_countdown`
  ///
  /// Requests the current value of the video countdown timer.
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "string",
  ///   "required": [],
  ///   "example": "00:00:01"
  /// }
  /// ```
  Future<Map<String, dynamic>> timerGetVideoCountdown() async {
    String url = '/v1/timer/videoCountdown';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [timerGetVideoCountdown]
  Future<Stream<Map<String, dynamic>>?> timerGetVideoCountdownStream() async {
    String url = '/v1/timer/videoCountdown';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `transportPlay` -> `/v1/transport/{layer}/play`
  ///
  /// Plays the content on the specified layer (presentation, announcement, audio).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The layer to perform the transport operation on
  ///
  /// - Should be one of: `presentation`, `announcement`, `audio`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> transportPlay(String layer) async {
    String url = '/v1/transport/$layer/play';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `transportPause` -> `/v1/transport/{layer}/pause`
  ///
  /// Pauses the content on the specified layer (presentation, announcement, audio).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The layer to perform the transport operation on
  ///
  /// - Should be one of: `presentation`, `announcement`, `audio`
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> transportPause(String layer) async {
    String url = '/v1/transport/$layer/pause';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `transportSkipBackward` -> `/v1/transport/{layer}/skip_backward/{time}`
  ///
  /// Moves backward in the content on the specified layer by the specified number of seconds (presentation, announcement, audio).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The layer to perform the transport operation on
  ///
  /// - Should be one of: `presentation`, `announcement`, `audio`
  ///
  /// [time] : The number of seconds to skip
  ///
  /// Example: `15`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> transportSkipBackward(String layer, int time) async {
    String url = '/v1/transport/$layer/skipBackward/$time';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `transportSkipForward` -> `/v1/transport/{layer}/skip_forward/{time}`
  ///
  /// Moves forward in the content on the specified layer by the specified number of seconds (presentation, announcement, audio).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The layer to perform the transport operation on
  ///
  /// - Should be one of: `presentation`, `announcement`, `audio`
  ///
  /// [time] : The number of seconds to skip
  ///
  /// Example: `15`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> transportSkipForward(String layer, int time) async {
    String url = '/v1/transport/$layer/skipForward/$time';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `transportGoToEnd` -> `/v1/transport/{layer}/go_to_end`
  ///
  /// Moves to the end on a certain layer
  /// Moves to the end in the content on the specified layer or moves the specified number of seconds away from the end in the content on the specified layer (presentation, announcement, audio).
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The layer to perform the transport operation on
  ///
  /// - Should be one of: `presentation`, `announcement`, `audio`
  ///
  /// [time] : The number of seconds back from the end to move to, 0 if not specified
  ///
  /// Example: `15`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> transportGoToEnd(String layer, {int? time}) async {
    String url = '/v1/transport/$layer/goToEnd';
    Map<String, dynamic> query = {'time': time.toString()};

    return await call('get', url, params: query, httpAccept: 'application/json');
  }

  /// `transportTimeGet` -> `/v1/transport/{layer}/time`
  ///
  /// Requests the current transport time for the specified layer (presentation, announcement, audio).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The layer to perform the transport operation on
  ///
  /// - Should be one of: `presentation`, `announcement`, `audio`
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "number",
  ///   "required": [],
  ///   "example": 15.2
  /// }
  /// ```
  Future<Map<String, dynamic>> transportTimeGet(String layer) async {
    String url = '/v1/transport/$layer/time';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [transportTimeGet]
  Future<Stream<Map<String, dynamic>>?> transportTimeGetStream(String layer) async {
    String url = '/v1/transport/$layer/time';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `transportTimeSet` -> `/v1/transport/{layer}/time`
  ///
  /// Moves to the specified time for the specified layer (presentation, announcement, audio).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The layer to perform the transport operation on
  ///
  /// - Should be one of: `presentation`, `announcement`, `audio`
  ///
  /// [postBody] (required) : This is the data that must be sent with this request.
  ///
  /// Example:
  /// ```json
  /// 15.2
  /// ```
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> transportTimeSet(String layer, double postBody) async {
    String url = '/v1/transport/$layer/time';

    return await call('put', url, httpAccept: 'application/json');
  }

  /// `transportAutoAdvanceGet` -> `/v1/transport/{layer}/auto_advance`
  ///
  /// Requests the auto-advance status for the specified layer (presentation, announcement).
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [layer] (required) :
  /// The layer to perform the transport operation on
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "boolean",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> transportAutoAdvanceGet(String layer) async {
    String url = '/v1/transport/$layer/autoAdvance';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `transportAutoAdvanceCancel` -> `/v1/transport/{layer}/auto_advance`
  ///
  /// Cancels the auto-advance for the specified layer (presentation, announcement).
  ///
  ///
  ///
  /// ## PARAMETERS
  /// [layer] (required) :
  /// The layer to perform the transport operation on
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> transportAutoAdvanceCancel(String layer) async {
    String url = '/v1/transport/$layer/autoAdvance';

    return await call('delete', url, httpAccept: 'application/json');
  }

  /// `transportCurrentMediaGet` -> `/v1/transport/{layer}/current`
  ///
  /// Requests the details of the currently playing content for the specified layer (presentation, announcement, audio).
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [layer] : The layer to perform the transport operation on
  ///
  /// - Should be one of: `presentation`, `announcement`, `audio`
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "object",
  ///   "required": [
  ///     "is_playing",
  ///     "uuid",
  ///     "name",
  ///     "artist",
  ///     "audio_only",
  ///     "length"
  ///   ]
  /// }
  /// ```
  Future<Map<String, dynamic>> transportCurrentMediaGet(String layer) async {
    String url = '/v1/transport/$layer/current';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// Streaming version of [transportCurrentMediaGet]
  Future<Stream<Map<String, dynamic>>?> transportCurrentMediaGetStream(String layer) async {
    String url = '/v1/transport/$layer/current';

    return callStream('get', url, params: {'chunked': 'true'});
  }

  /// `triggerCue` -> `/v1/trigger/cue/{index}`
  ///
  /// Triggers the specified cue in the currently active playlist item.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [index] : The index of the cue to use. Respects the selected arrangement of cues.
  ///
  /// - Example (index): `0`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerCue(int index) async {
    String url = '/v1/trigger/cue/$index';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerPlaylist` -> `/v1/trigger/playlist/{playlist_id}/{item_id}/{cue_index}`
  ///
  /// Triggers the specified cue in the specified item in the specified playlist.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [playlistId] : The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// [itemId] : The ID of the item within a playlist, either UUID, name, or index, in order of interpretation and search priority.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Presentation Name`
  /// - Example (by_index): `3`
  ///
  /// [cueIndex] : The index of the cue (slide) to use. Respects the selected arrangement of cues. For media playlist items pass 0 here.
  ///
  /// - Example (cue_index): `0`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerPlaylist(String playlistId, String itemId, int cueIndex) async {
    String url = '/v1/trigger/playlist/$playlistId/$itemId/$cueIndex';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerMedia` -> `/v1/trigger/media/{playlist_id}/{item_id}`
  ///
  /// Triggers the specified media item in the specified media playlist.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [playlistId] : The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// [itemId] : The ID of the item within a playlist, either UUID, name, or index, in order of interpretation and search priority.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Presentation Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerMedia(String playlistId, String itemId) async {
    String url = '/v1/trigger/media/$playlistId/$itemId';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerMediaNext` -> `/v1/trigger/media/next`
  ///
  /// Triggers the next item in the currently active media playlist.
  ///
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerMediaNext() async {
    String url = '/v1/trigger/media/next';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerMediaPrevious` -> `/v1/trigger/media/previous`
  ///
  /// Triggers the previous item in the currently active media playlist.
  ///
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerMediaPrevious() async {
    String url = '/v1/trigger/media/previous';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerAudio` -> `/v1/trigger/audio/{playlist_id}/{item_id}`
  ///
  /// Triggers the specified audio item in the specified audio playlist.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [playlistId] : The ID of the playlist, either UUID, name, or index, in order of interpretation and search priority. A path can also be specified to identify playlists within folders. UUID and name matches are searched through the entire playlist tree. Because UUIDs are unique a path is not necessary. A name path is not necessary unless there are multiple playlists with the same name in different folders. A partial path of names can be used as well. Indices only index into the immediate children at each level of the tree so an index path is requred to access playlists within folders if only using indices. A mix of UUIDs, names, and indices can be used for the path if desired.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Playlist Name`
  /// - Example (by_name_with_path): `Folder1/Folder2/Playlist Name`
  /// - Example (by_index): `3`
  /// - Example (by_index_path): `2/0/1`
  /// - Example (by_mixed_path): `3C39C433-5C18-4F51-B357-55BB870227C4/Folder Name/0`
  ///
  /// [itemId] : The ID of the item within a playlist, either UUID, name, or index, in order of interpretation and search priority.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Presentation Name`
  /// - Example (by_index): `3`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> triggerAudio(String playlistId, String itemId) async {
    String url = '/v1/trigger/audio/$playlistId/$itemId';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerAudioNext` -> `/v1/trigger/audio/next`
  ///
  /// Triggers the next item in the currently active audio playlist.
  ///
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerAudioNext() async {
    String url = '/v1/trigger/audio/next';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerAudioPrevious` -> `/v1/trigger/audio/previous`
  ///
  /// Triggers the previous item in the currently active audio playlist.
  ///
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerAudioPrevious() async {
    String url = '/v1/trigger/audio/previous';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerVideoInput` -> `/v1/trigger/video_input/{id}`
  ///
  /// Triggers the specified video input in the video input playlist.
  /// Video input sources must be added to the Video Input playlist in the Media Bin in order to be triggered with this endpoint.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [id] : The ID of the video input, either name, index or UUID.
  ///
  /// - Example (by_name): `Input 1`
  /// - Example (by_index): `3`
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerVideoInput(String id) async {
    String url = '/v1/trigger/videoInput/$id';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerLibrary` -> `/v1/trigger/library/{library_id}/{presentation_id}/{index}`
  ///
  /// Triggers the specified slide in the specified presentation in the specified library.
  ///
  ///
  ///
  /// ## PARAMETERS
  ///
  /// [libraryId] : The ID of the library, either UUID, name, or index, in order of interpretation and search priority.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Library Name`
  /// - Example (by_index): `3`
  ///
  /// [presentationId] : The ID of the presentation, either UUID, name, or index, in order of interpretation and search priority.
  ///
  /// - Example (by_uuid): `3C39C433-5C18-4F51-B357-55BB870227C4`
  /// - Example (by_name): `Presentation Name`
  /// - Example (by_index): `3`
  ///
  /// [index] : The index of the cue to use. Respects the selected arrangement of cues.
  ///
  /// - Example (index): `0`
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  /// ## RESPONSE 400:
  ///
  /// The request was not valid.
  ///
  /// content-type: ``
  ///
  Future<bool> triggerLibrary(String libraryId, String presentationId, int index) async {
    String url = '/v1/trigger/library/$libraryId/$presentationId/$index';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerNext` -> `/v1/trigger/next`
  ///
  /// Triggers the next cue or item in the currently active playlist or library.
  ///
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerNext() async {
    String url = '/v1/trigger/next';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `triggerPrevious` -> `/v1/trigger/previous`
  ///
  /// Triggers the previous cue or item in the currently active playlist or library.
  ///
  ///
  ///
  /// ## RESPONSE 204:
  ///
  /// The request was processed successfully. There is no response body.
  ///
  /// content-type: `NONE`
  ///
  Future<bool> triggerPrevious() async {
    String url = '/v1/trigger/previous';

    return await call('get', url, httpAccept: 'application/json');
  }

  /// `videoInputsGet` -> `/v1/video_inputs`
  ///
  /// Requests a list of the configured and triggerable video inputs.
  /// Triggerable video inputs come from the Video Inputs playlist in the Media Bin. Once the video input is
  /// added there it can be triggered with [GET /v1/trigger/video_input/{id}](#/Trigger/triggerVideoInput)
  ///
  ///
  ///
  /// ## RESPONSE 200:
  ///
  /// The request was processed successfully.
  ///
  /// content-type: `application/json`
  ///
  /// schema:
  /// ```json
  /// {
  ///   "type": "array",
  ///   "required": []
  /// }
  /// ```
  Future<Map<String, dynamic>> videoInputsGet() async {
    String url = '/v1/videoInputs';

    return await call('get', url, httpAccept: 'application/json');
  }
}
